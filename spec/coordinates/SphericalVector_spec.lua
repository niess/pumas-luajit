local ffi = require('ffi')
local pumas = require('pumas')
local metatype = require('pumas.metatype')
local util = require('spec.util')


describe('SphericalVector', function ()
    describe('constructor', function ()
        it('should default to zero', function ()
            local c = pumas.SphericalVector()
            assert.are.equals(c.norm, c.theta, c.phi, 0)
            assert.is.equal(c.frame, nil)
        end)

        it('should properly set attributes', function ()
            local t = pumas.UnitaryTransformation()
            local c = pumas.SphericalVector(1, 2, 3, t)
            assert.is.equal(c.norm, 1)
            assert.is.equal(c.theta, 2)
            assert.is.equal(c.phi, 3)
            assert.is.equal(c.frame, t)
        end)

        it('should properly set keyword attributes', function ()
            local t = pumas.UnitaryTransformation()
            local c = pumas.SphericalVector{
                norm = 1, theta = 2, phi = 3, frame = t}
            assert.is.equal(c.norm, 1)
            assert.is.equal(c.theta, 2)
            assert.is.equal(c.phi, 3)
            assert.is.equal(c.frame, t)
        end)

        it('should initialise from another instance', function ()
            local t = pumas.UnitaryTransformation()
            local c0 = pumas.SphericalVector(1, 2, 3, t)
            local c1 = pumas.SphericalVector(c0)
            assert.is.equal(c1.norm, 1)
            assert.is.equal(c1.theta, 2)
            assert.is.equal(c1.phi, 3)
            assert.is.equal(c1.frame, t)
        end)

        it('should return a Coordinates cdata', function ()
            local c = pumas.SphericalVector()
            assert.is.equal(metatype(c), 'Coordinates')
        end)
    end)

    describe('clone', function ()
        it('should raise an error on missing self', function ()
            local c = pumas.SphericalVector()
            assert.has_error(function ()
                c.clone()
            end, "bad argument #1 to 'clone' (expected a Coordinates cdata, \z
                got nil)")
        end)

        it('should return a copy', function ()
            local t = pumas.UnitaryTransformation()
            local c0 = pumas.SphericalVector(1, 2, 3, t)
            local c1 = c0:clone()
            assert.is_not.equal(c0, c1)
            assert.is.equal(c1.norm, 1)
            assert.is.equal(c1.theta, 2)
            assert.is.equal(c1.phi, 3)
            assert.is.equal(c1.frame, t)
            assert.is.equal(metatype(c1), metatype(c0))
        end)
    end)

    describe('get', function ()
        it('should raise an error on missing self', function ()
            local c = pumas.SphericalVector()
            assert.has_error(function ()
                c.get()
            end, "bad argument #1 to 'get' (expected a Coordinates cdata, \z
                got nil)")
        end)

        it('should return an equivalent C array', function ()
            local c = pumas.SphericalVector(3, 0, 0)
            local a = c:get()
            assert.is.True(ffi.istype('double [3]', a))
            assert.is.equal(a[0], 0)
            assert.is.equal(a[1], 0)
            assert.is.equal(a[2], 3)
        end)

        it('should transform back to the simulation frame', function ()
            local t = util.Reflection()
            local c = pumas.SphericalVector(3, 0, 0, t)
            local a = c:get()
            assert.is.equal(a[0], 0)
            assert.is.equal(a[1], 0)
            assert.is.equal(a[2], -3)
        end)
    end)

    describe('set', function ()
        it('should raise an error on missing self', function ()
            local c = pumas.SphericalVector()
            assert.has_error(function ()
                c.set(pumas.SphericalVector())
            end, "bad number of argument(s) to 'set' (expected 2, got 1)")
        end)

        it('should accept a C array', function ()
            local c = pumas.SphericalVector()
            c:set(ffi.new('double [3]', 0, 0, 1))
            assert.is.equal(c.norm, 1)
            assert.is.equal(c.theta, 0)
            assert.is.equal(c.phi, 0)
            assert.is.equal(c.frame, nil)
        end)

        it('should accept another vector instance of same type', function ()
            local c = pumas.SphericalVector()
            local t = util.Reflection()
            c:set(pumas.SphericalVector(1, 2, 3, t))
            assert.is.equal(c.norm, 1)
            assert.is.equal(c.theta, 2)
            assert.is.equal(c.phi, 3)
            assert.is.equal(c.frame, t)
        end)

        it('should accept another vector instance of different type',
        function ()
            local c = pumas.SphericalVector()
            local t = util.Reflection()
            c:set(pumas.CartesianVector(0, 0, 3, t))
            assert.is.equal(c.norm, 3)
            assert.is.equal(c.theta, 0)
            assert.is.equal(c.phi, 0)
            assert.is.equal(c.frame, t)
        end)

        it('should not accept a point instance', function ()
            local c = pumas.SphericalVector()
            assert.has_error(function ()
                c:set(pumas.SphericalPoint())
            end, "bad argument(s) to 'set' (not implemented)")
        end)

        it('should not accept other types', function ()
            assert.has_error(function ()
                local c = pumas.SphericalVector()
                c:set(1)
            end, "bad argument #2 to 'set' (expected a Coordinates cdata, \z
                got a number)")
        end)

        it('should return an instance of self', function ()
            local c = pumas.SphericalVector()
            assert.is.equal(c, c:set(ffi.new('double [3]')))
        end)
    end)

    describe('transform', function ()
        it('should raise an error on missing self', function ()
            local c = pumas.SphericalVector()
            local t = pumas.UnitaryTransformation()
            assert.has_error(function ()
                c.transform(t)
            end, "bad argument #1 to 'transform' (expected a Coordinates \z
                cdata, got a UnitaryTransformation cdata)")
        end)

        it('should do nothing when same frame', function ()
            local c = pumas.SphericalVector(1, 2, 3)
            c:transform()
            assert.is.equal(c.norm, 1)
            assert.is.equal(c.theta, 2)
            assert.is.equal(c.phi, 3)
            assert.is.equal(c.frame, nil)
        end)

        it('should transform to the simulation frame', function ()
            local t = util.Reflection()
            local c = pumas.SphericalVector(3, 0, 0, t)
            c:transform()
            assert.is.equal(c.norm, 3)
            assert.is.equal(c.theta, math.pi)
            assert.is.equal(c.phi, 0)
            assert.is.equal(c.frame, nil)
        end)

        it('should transform from the simulation frame', function ()
            local c = pumas.SphericalVector(3, 0, 0)
            local t = util.Reflection()
            c:transform(t)
            assert.is.equal(c.norm, 3)
            assert.is.equal(c.theta, math.pi)
            assert.is.equal(c.phi, 0)
            assert.is.equal(c.frame, t)
        end)

        it('should transform between two frames', function ()
            local t0 = util.Reflection()
            local c = pumas.SphericalVector(3, 0, 0, t0)
            local t1 = util.Reflection()
            c:transform(t1)
            assert.is.equal(c.norm, 3)
            assert.is.equal(c.theta, 0)
            assert.is.equal(c.phi, 0)
            assert.is.equal(c.frame, t1)
        end)

        it('should return an instance of self', function ()
            local c = pumas.SphericalVector()
            assert.is.equal(c, c:transform())
        end)
    end)
end)
